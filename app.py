# -*- coding: utf-8 -*-
"""ejercicio Clase 11: Dashboard con plotly.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lhebsMr3WinwWggK0RMw36p6qM8zE89d
"""
import pandas as pd
from dash import Dash, dcc, html, Input, Output
import plotly.express as px
import dash_bootstrap_components as dbc

## 1. Cargar el DataFrame
df = pd.read_excel("CONSOLIDADO DATOS.xlsx",header=0)
df

"""## Utilizar http://dash-bootstrap-components.com/. Es una libreria con componentes predefinidos para construir el reporte de una manera mucho más sencilla"""

## 3. Crear la aplicación Dash
external_stylesheets = [dbc.themes.QUARTZ]  ## Podemos usar diferentes temas preconfigurados
app = Dash(__name__, external_stylesheets=external_stylesheets)
app.title = "Reporte de pedidos de comida online"

"""https://www.dash-bootstrap-components.com/docs/themes/  Temas que puedo usar"""

### 4. Definir el layout de la aplicación
# Definir las opciones y rangos antes de construir el layout
estado_civil_unique = df['ESTADO CIVIL'].unique()
genero_unique = df['GENERO'].unique()
edad_min_val = df['EDAD'].min()
edad_max_val = df['EDAD'].max()
numero_hijos_unique = df['NÚM. HIJOS'].unique()

app.layout = dbc.Container([
    dbc.Row([html.H1("Reporte de pedidos de comida online")]),
    dbc.Row([
          dbc.Col([
              html.Label("Selecciona el estado civil:"), # Corrected label
              dcc.Dropdown(
              id='selector_estado_civil',
              options=[{'label': ec, 'value': ec} for ec in estado_civil_unique], # Corrected loop
              value=estado_civil_unique[0]  # Valor por defecto
          )]),
          dbc.Col([
              html.Label("Selecciona el género:"), # Corrected label
              dcc.RadioItems(
              id='selector_genero',
              options=[{'label': g, 'value': g} for g in genero_unique], # Corrected loop
              value=genero_unique[0]  # Valor por defecto
          )]),
          dbc.Col([
              html.Label("Selecciona el rango de edad:"),
              dcc.RangeSlider(
              id='selector_edad',
              min=edad_min_val, # Using defined variable
              max=edad_max_val, # Using defined variable
              value=[edad_min_val, edad_max_val],
              marks={i: str(i) for i in range(edad_min_val, edad_max_val + 1)}, # Corrected 'edad' function
              step=1
          )]),
          dbc.Col([
              html.Label("Selecciona el número de hijos:"), # Corrected label to match column
              dbc.Checklist(
                  id='selector_numero_hijos',
                  options=[{'label': num_hijo, 'value': num_hijo} for num_hijo in numero_hijos_unique], # Corrected loop
                  value=[numero_hijos_unique[0]],
              )
          ])

        ]),
    dbc.Row([
        dbc.Col([
            dcc.Graph(id='grafica_barras')
        ]),
        dbc.Col([
            dcc.Graph(id='grafica_torta')
        ]),
        dbc.Col([
            dcc.Graph(id='grafica_area')
        ])
    ])
])

### 5. Definir los callbacks (Si es necesario)
@app.callback(
    [Output('grafica_barras', 'figure'),
     Output('grafica_torta', 'figure'),
     Output('grafica_area', 'figure')],
    [Input('selector_estado_civil', 'value'),
     Input('selector_genero', 'value'),
     Input('selector_edad', 'value'),
     Input('selector_numero_hijos', 'value')]
)
def crear_graficas(valor_estado_civil, valor_genero, valor_edad, valor_numero_hijos):
    # Partimos del dataframe completo
    df_filtrado = df.copy()

    # Filtro por estado civil
    if valor_estado_civil is not None:
        df_filtrado = df_filtrado[df_filtrado['ESTADO CIVIL'] == valor_estado_civil]

    # Filtro por género
    if valor_genero is not None:
        df_filtrado = df_filtrado[df_filtrado['GENERO'] == valor_genero]

    # Filtro por rango de edad (RangeSlider devuelve [min, max])
    if valor_edad is not None and len(valor_edad) == 2:
        df_filtrado = df_filtrado[
            (df_filtrado['EDAD'] >= valor_edad[0]) &
            (df_filtrado['EDAD'] <= valor_edad[1])
        ]

    # Filtro por número de hijos (CheckList devuelve lista)
    if valor_numero_hijos:
        df_filtrado = df_filtrado[df_filtrado['NÚM. HIJOS'].isin(valor_numero_hijos)]

    # Si no hay datos luego de filtrar, devolvemos gráficas vacías "amigables"
    if df_filtrado.empty:
        grafica_barras = px.bar(title="Sin datos para los filtros seleccionados")
        grafica_torta = px.pie(title="Sin datos para los filtros seleccionados")
        grafica_area = px.area(title="Sin datos para los filtros seleccionados")

        for fig in [grafica_barras, grafica_torta, grafica_area]:
            fig.update_layout(
                plot_bgcolor='rgba(0, 0, 0, 0)',
                paper_bgcolor='rgba(0, 0, 0, 0)'
            )
        return grafica_barras, grafica_torta, grafica_area

    # ====================================
    # 1) GRÁFICA DE BARRAS
    #    Personas por estado civil y número de hijos
    # ====================================
    conteo_ec_hijos = (
        df_filtrado
        .groupby(['ESTADO CIVIL', 'NÚM. HIJOS'], as_index=False)['NOMBRES Y APELLIDOS']
        .count()
        .rename(columns={'NOMBRES Y APELLIDOS': 'CONTEO'})
        .sort_values(by='NÚM. HIJOS', ascending=False)
    )

    grafica_barras = px.bar(
        conteo_ec_hijos,
        x='ESTADO CIVIL',
        y='CONTEO',
        color='NÚM. HIJOS',
        title='Número de personas por estado civil y número de hijos',
        color_discrete_sequence=['#65c78c', '#f74a50']
    )

    # ====================================
    # 2) GRÁFICA DE TORTA
    #    Distribución de estado civil
    # ====================================
    conteo_estado_civil = (
        df_filtrado
        .groupby('ESTADO CIVIL', as_index=False)['NOMBRES Y APELLIDOS']
        .count()
        .rename(columns={'NOMBRES Y APELLIDOS': 'CONTEO'})
    )

    grafica_torta = px.pie(
        conteo_estado_civil,
        names='ESTADO CIVIL',
        values='CONTEO',
        title='Distribución de estado civil en los datos filtrados',
        color_discrete_sequence=['#65c78c', '#f74a50']
    )

    # ====================================
    # 3) GRÁFICA DE ÁREA
    #    Cantidad de personas por edad (curva de distribución)
    # ====================================
    conteo_edad = (
        df_filtrado
        .groupby('EDAD', as_index=False)['NOMBRES Y APELLIDOS']
        .count()
        .rename(columns={'NOMBRES Y APELLIDOS': 'CONTEO'})
        .sort_values(by='EDAD')
    )

    grafica_area = px.area(
        conteo_edad,
        x='EDAD',
        y='CONTEO',
        title='Distribución de personas por edad (datos filtrados)'
    )

    # Fondos transparentes para las tres gráficas
    for fig in [grafica_barras, grafica_torta, grafica_area]:
        fig.update_layout(
            plot_bgcolor='rgba(0, 0, 0, 0)',
            paper_bgcolor='rgba(0, 0, 0, 0)'
        )

    return grafica_barras, grafica_torta, grafica_area
